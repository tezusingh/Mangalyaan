{"version":3,"sources":["visulaizer/instructions.js","visulaizer/navbar.js","algorithms/utility.js","algorithms/dijkstra.js","node/node.js","algorithms/astar.js","algorithms/greedy_bfs.js","timer.js","visulaizer/visualizer.js","algorithms/bfs.js","App.js","reportWebVitals.js","index.js"],"names":["Component","Navbar","constructor","arguments","state","currentAlgorithm","message","selectAlgorithm","name","this","setState","document","getElementById","innerHTML","concat","render","_jsx","children","className","_jsxs","href","type","id","role","class","onClick","value","htmlFor","props","resetGrid","clearPath","visualizeAlgorithm","Queue","items","Array","dequeue","shift","enqueue","element","push","empty","length","clear","getNeighbours","i","j","grid","neighbours","dx","dy","checked","d","rr","cc","no_of_row","no_of_column","isVisited","isWall","minHeap","heap","isEmpty","getMin","min","pop","siftDown","item","siftUp","parent","index","Math","floor","leftChildValid","rightChildValid","newIndex","val","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","distance","updateUnvisitedNeighbors","node","neighboursIndex","row","col","forEach","indices","m","n","neighbour","currNode","algo","DiagonalId","includes","weight","previousNode","updateNeighbours","Node","isFinish","isStart","isvisited","onMouseDown","onMouseEnter","onMouseUp","f","g","h","extraClassName","endNode","newGCost","estimation_cost","getDistance","newCost","diagonal","abs","newf","minutes","seconds","milisec","interval","started","startTime","Date","timer","milisecond","innerText","start","setInterval","clearInterval","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","isWPressed","height","window","innerHeight","width","innerWidth","Visualizer","startchange","endchange","mouseIsPressed","handleMouseDown","setTimeout","newGrid","slice","newNode","getNewGridWithWallToggled","handleMouseEnter","console","log","changeStartPoint","newstGrid","changeEndPoint","handleMouseUp","startNode","finishNode","visitedNodesInOrder","nodesInShortestPathOrder","nodes","getAllNodes","closestNode","Infinity","dijkstra","currentNode","unshift","getNodesInShortestPathOrderOfDijkstra","myQueue","r","c","k","BFS","getNodesInShortestPathOrderOfBFS","AStar","openList","cell","getNodesInShortestPathOrderOfAStar","Greedy_BFS","getNodesInShortestPathOrderOfGreedyBfs","animateAlgorithm","currentRow","createNode","gridNew","componentDidMount","getInitialGrid","animateShortestPath","iswall","addEventListener","e","key","map","rowIdx","nodeIdx","isWeighted","undefined","previousStart","newStart","previousEnd","newEnd","App","reportWebVitals","onPerfEntry","Function","then","_ref","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","React","StrictMode"],"mappings":"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","file":"static/js/main.d0ccd80e.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport './visualizer.css';\nimport '../node/node.css';\n// import Collapse from 'react-bootstrap/Collapse';\n\n class Instructions  extends Component {\n    state = {  } \n\n    handleclick =()=>{\n       document.getElementById('hide-instruct').classList.toggle(\"hide-card\");\n       if( document.getElementById(\"btn-instruct\").innerHTML=== \"open\")\n       {\n        document.getElementById(\"btn-instruct\").innerHTML= \"close\";\n       }\n       else \n       {\n        document.getElementById(\"btn-instruct\").innerHTML= \"open\";\n       }\n    }\n    render() { \n        return (  <div\n          class=\"info-bar\"\n          id=\"info-bar\"\n        >\n          <div class=\"card \">\n            <div class=\"card-header\">\n              <a\n                id=\"info-header\"\n                href=\"#\"\n              >\n                Instructions\n              </a>\n               \n              <button \n              className=\"btn btn-outline-primary py-0 rounded-pill\"  \n              onClick= { this.handleclick} \n              id =\"btn-instruct\"\n              >close</button>\n            </div>\n            {/* <div\n              id=\"collapse\"\n              class=\"collapse show\"\n              data-parent=\"#info-bar\"\n            > */}\n            {/* < Collapse> */}\n              <div class=\"card-body\" id=\"hide-instruct\">\n                <div\n                  id=\"info-description\"\n                  class=\"info-description\"\n                >\n                  <ul>\n                    <li>Click within the grid and drag your mouse to draw obstacles represented by  \n                      <span class=\"node-wall design-node\" ></span> </li>\n                    <li>Drag the <span class=\"node-start design-node\"></span> Start node to set the start position</li>\n                    <li>Drag the <span class=\"node-finish  design-node\"></span> End node to set the end position</li>\n                    <li>Click and press the 'W' key on your keyboard and drag your mouse to add <span\n                        class=\"node-weighted  design-node\"\n                      ></span> Weights for weighted algorithms.\n                    </li>\n                    <li>Choose an algorithm from the  Navbar.</li>\n                    <li>Click Start button in the upper right corner of the side bar to start the visualization.</li>\n                    <li>The <span class=\"node-visited  design-node\"></span> Visited nodes will be highlighted along the <span\n                        class=\"node-shortest-path  design-node\"\n                      ></span> Shortest path.</li>\n                  </ul>\n                </div>\n              </div>\n          \n            {/* </Collapse> */}\n          </div>\n        </div>\n        \n        );\n    }\n}\n \nexport default Instructions ;"," import React, { Component } from 'react';\nimport Instructions from './instructions';\n//import { dijkstra } from './algorithms/dijkstra';\n class Navbar extends Component {\n   state = {  \n     currentAlgorithm : null,  \n     message : 'select Algorithm'\n     } \n    \n\n     selectAlgorithm= ( name )=>{ \n       this.setState({ message : 'Apply'+ ' ' +name });  \n       this.setState({  currentAlgorithm :name });   \n        // console.log( this.props); v \n        document.getElementById('input-message').innerHTML= ` Apply ${ name} Algorithm`;\n        // document.getElementById('algo-name').innerHTML= `  ${ name} Algorithm`;\n      \n       \n     }\n   render() {  \n      \n     return (  \n      <div>\n        \n        <nav className=\"navbar navbar-expand-lg navbar-light navColor\">\n<div className=\"container-fluid\">\n  <a className=\"navbar-brand\" href=\"#\">Mangalyaan</a>\n  <button className=\"navbar-toggler\" type=\"button\" data-bs-toggle=\"collapse\" data-bs-target=\"#navbarSupportedContent\" aria-controls=\"navbarSupportedContent\" aria-expanded=\"false\" aria-label=\"Toggle navigation\">\n    <span className=\"navbar-toggler-icon\"></span>\n  </button>\n  <div className=\"collapse navbar-collapse\" id=\"navbarSupportedContent\">\n    <ul className=\"navbar-nav me-auto mb-2 mb-lg-0 mx-3\">\n    <li className=\"nav-item dropdown ms-0\">\n        <a className=\"nav-link dropdown-toggle \" href=\"#\" id=\"InstructionDropdown\" role=\"button\" data-bs-toggle=\"dropdown\" aria-expanded=\"false\">\n          Instructions\n        </a>\n        <ul className=\"dropdown-menu\" aria-labelledby=\"InstructionDropdown\">\n          <li><a className=\"dropdown-item\" >Click within the grid and drag your mouse to draw obstacles represented by  \n                      <span class=\"node-wall design-node\" ></span></a></li>\n          <li><a className=\"dropdown-item\" >Drag the <span class=\"node-start design-node\"></span> Start node to set the start position</a></li>\n          <li><a className=\"dropdown-item\">Drag the <span class=\"node-finish  design-node\"></span> End node to set the end position</a></li>\n          <li><a className=\"dropdown-item\">Click and press the 'W' key on your keyboard and drag your mouse to add <span\n                        class=\"node-weighted  design-node\"\n                      ></span> Weights for weighted algorithms.</a></li>\n           <li><a className=\"dropdown-item\">Choose an algorithm from the  Navbar.</a></li>\n           <li><a className=\"dropdown-item\">Click Start button in the upper right corner of the side bar to start the visualization.</a></li>\n           <li><a className=\"dropdown-item\">The <span class=\"node-visited  design-node\"></span> Visited nodes will be highlighted along the <span\n                        class=\"node-shortest-path  design-node\"\n                      ></span> Shortest path</a></li>\n           \n        </ul>\n      \n      </li>\n      <li className=\"nav-item dropdown ms-0\">\n        <a className=\"nav-link dropdown-toggle \" href=\"#\" id=\"navbarDropdown\" role=\"button\" data-bs-toggle=\"dropdown\" aria-expanded=\"false\">\n          Select Algorithms\n        </a>\n        <ul className=\"dropdown-menu\" aria-labelledby=\"navbarDropdown\">\n          <li><a className=\"dropdown-item\" id='startButtonDijkstra'   onClick={() =>this.selectAlgorithm( 'dijkstra')} href=\"#\">Dijkstra</a></li>\n          <li><a className=\"dropdown-item\" id='startButtonBFS'  onClick={() =>this.selectAlgorithm( 'BFS')} href=\"#\">Breath First Search</a></li>\n          <li><a className=\"dropdown-item\" id='startButtonAStar'  onClick={() =>this.selectAlgorithm( 'A*')} href=\"#\">A*</a></li>\n          <li><a className=\"dropdown-item\" id='startButtonGreedy'  onClick={() =>this.selectAlgorithm( 'Greedy-best-first')}  href=\"#\">Greedy Best First Search</a></li>\n        </ul>\n      \n      </li>\n     \n      <li className=\"nav-item mx-3\">\n         <div className=\"form-check form-switch mt-2\">\n           <input className=\"form-check-input\" type=\"checkbox\" value=\"\" id=\"diagonal-flag\"></input>\n            <label className=\"form-check-label\" htmlFor=\"flexCheckDefault\">\n             Allow Diagonal\n            </label>\n           </div>\n      </li>  \n      <li className=\"nav-item mx-3\">\n      <button className=\"btn btn-outline-info rounded-pill py-1 px-4 mt-1\" onClick={ this.props.resetGrid}> Reset Grid</button>\n      </li> \n      <li className=\"nav-item mx-3\">\n      <button className=\"btn btn-outline-info rounded-pill  py-1 px-4 mt-1\" onClick={ this.props.clearPath}> Clear Path and Weights</button>\n      </li> \n\n      \n      \n    </ul>\n   \n    \n    {/* <form className=\"d-flex\"> */}\n      {/* <input className=\"form-control me-2\" type=\"search\" placeholder=\"Search\" aria-label=\"Search\"/> */}\n      <button className=\"btn btn-outline-success rounded-pill px-5 \"  id=\"actualStartButton\" onClick={ ()=> this.props.visualizeAlgorithm(this.state.currentAlgorithm)}>{ this.state.message}</button>\n  {/* <Instructions/> */}\n  </div>\n</div>\n</nav> \n</div> \n\n      );\n   }\n }\n  \n export default Navbar;\n \n \n \n \n","import '../visulaizer/navbar';\nimport {no_of_column , no_of_row} from'../visulaizer/visualizer'\n\nexport class Queue {\n    constructor() {\n      this.items = new Array();\n    }\n  \n    dequeue() {\n      return this.items.shift();\n    }\n  \n    enqueue(element) {\n      this.items.push(element);\n      return;\n    }\n  \n    empty() {\n      return this.items.length === 0;\n    }\n  \n    clear() {\n      this.items = new Array();\n      return;\n    }\n  }\n  \n  export function getNeighbours(i, j,grid) {\n    let neighbours = [];\n    // direction vectors\n    // 0-3: East, South, West, North\n    // 4-7: South-East, North-East, South-West, North-West\n    const dx = [1, 0, -1, 0, 1, 1, -1, -1];\n    const dy = [0, 1, 0, -1, 1, -1, 1, -1];\n    const diagonal = document.getElementById(\"diagonal-flag\").checked;\n     \n    let length; // length of direction vector\n    if (diagonal === false) { \n        \n      length = 4;\n    } else length = 8;\n  \n    for (let d = 0; d < length; d++) {\n      let rr = i + dx[d];\n      let cc = j + dy[d];\n      if (rr >= 0 && rr < no_of_row && cc >= 0 && cc < no_of_column) {\n        if (grid[rr][cc].isVisited || grid[rr][cc].isWall === \"true\") {\n          continue;\n        } // if d < 4, push elements else if d >= 4, check for diagonal walls\n        else if (d < 4) {\n          neighbours.push([rr, cc]);\n        }  \n        else if (\n          d === 4 &&\n          grid[i][j + 1].isWall !== \"true\" &&\n          grid[i + 1][j].isWall !== \"true\"\n        ) {\n          neighbours.push([rr, cc]);\n        }  \n        else if (\n          d === 5 &&\n          grid[i][j - 1].isWall !== \"true\" &&\n          grid[i + 1][j].isWall !== \"true\"\n        ) {\n          neighbours.push([rr, cc]);\n        }\n         else if (\n          d === 6 &&\n          grid[i - 1][j].isWall !== \"true\" &&\n          grid[i][j + 1].isWall !== \"true\"\n        ) {\n          neighbours.push([rr, cc])\n        } \n        else if (\n          d === 7 &&\n          grid[i - 1][j].isWall !== \"true\" &&\n          grid[i][j - 1].isWall !== \"true\"\n        ) {\n          neighbours.push([rr, cc]);\n        }\n      }\n    }\n    return neighbours;\n  } \n\n\n  \n  export class minHeap {\n    constructor() {\n      this.heap = [];\n    }\n    isEmpty() {\n      return this.heap.length === 0;\n    }\n    clear() {\n      this.heap = [];\n      return;\n    }\n    getMin() {\n      if (this.isEmpty()) {\n        return null;\n      }\n      var min = this.heap[0];\n      this.heap[0] = this.heap[this.heap.length - 1];\n      this.heap[this.heap.length - 1] = min;\n      this.heap.pop();\n      if (!this.isEmpty()) {\n        this.siftDown(0);\n      }\n      return min;\n    }\n    push(item) {\n      this.heap.push(item);\n      this.siftUp(this.heap.length - 1);\n      return;\n    }\n    parent(index) {\n      if (index === 0) {\n        return null;\n      }\n      return Math.floor((index - 1) / 2);\n    }\n    children(index) {\n      return [index * 2 + 1, index * 2 + 2];\n    }\n    siftDown(index) {\n      var children = this.children(index);\n      var leftChildValid = children[0] <= this.heap.length - 1;\n      var rightChildValid = children[1] <= this.heap.length - 1;\n      var newIndex = index;\n      if (leftChildValid && this.heap[newIndex][0] > this.heap[children[0]][0]) {\n        newIndex = children[0];\n      }\n      if (rightChildValid && this.heap[newIndex][0] > this.heap[children[1]][0]) {\n        newIndex = children[1];\n      }\n      // No sifting down needed\n      if (newIndex === index) {\n        return;\n      }\n      var val = this.heap[index];\n      this.heap[index] = this.heap[newIndex];\n      this.heap[newIndex] = val;\n      this.siftDown(newIndex);\n      return;\n    }\n    siftUp(index) {\n      var parent = this.parent(index);\n      if (parent !== null && this.heap[index][0] < this.heap[parent][0]) {\n        var val = this.heap[index];\n        this.heap[index] = this.heap[parent];\n        this.heap[parent] = val;\n        this.siftUp(parent);\n  }\n      return;\n    }\n  }\n  \n  // export function getNeighbours(i, j,grid) {\n  //   let neighbours = [];\n  //   // direction vectors\n  //   // 0-3: East, South, West, North\n  //   // 4-7: South-East, North-East, South-West, North-West\n  //   const dx = [1, 0, -1, 0, 1, 1, -1, -1];\n  //   const dy = [0, 1, 0, -1, 1, -1, 1, -1];\n  //   const diagonal = document.getElementById(\"diagonal-flag\").checked;\n     \n  //   let length; // length of direction vector\n  //   if (diagonal === false) { \n        \n  //     length = 4;\n  //   } else length = 8;\n  \n  //   for (let d = 0; d < length; d++) {\n  //     let rr = i + dx[d];\n  //     let cc = j + dy[d];\n  //     if (rr >= 0 && rr < 20 && cc >= 0 && cc < 20) {\n  //       //console.log(grid[rr][cc]);\n  //       if (grid[rr][cc].isVisited || grid[rr][cc].isWall === \"true\") {\n  //         continue;\n  //       } // if d < 4, push elements else if d >= 4, check for diagonal walls\n  //       else if (d < 4) {\n  //         neighbours.push([rr, cc]);\n  //       }  \n  //       else if (\n  //         d === 4 &&\n  //         grid[i][j + 1].isWall !== \"true\" &&\n  //         grid[i + 1][j].isWall !== \"true\"\n  //       ) {\n  //         neighbours.push([rr, cc]);\n  //       }  \n  //       else if (\n  //         d === 5 &&\n  //         grid[i][j - 1].isWall !== \"true\" &&\n  //         grid[i + 1][j].isWall !== \"true\"\n  //       ) {\n  //         neighbours.push([rr, cc]);\n  //       }\n  //        else if (\n  //         d === 6 &&\n  //         grid[i - 1][j].isWall !== \"true\" &&\n  //         grid[i][j + 1].isWall !== \"true\"\n  //       ) {\n  //         neighbours.push([rr, cc])\n  //       } \n  //       else if (\n  //         d === 7 &&\n  //         grid[i - 1][j].isWall !== \"true\" &&\n  //         grid[i][j - 1].isWall !== \"true\"\n  //       ) {\n  //         neighbours.push([rr, cc]);\n  //       }\n  //     }\n  //   }\n  //   return neighbours;\n  // } \n\n\n  \n  ","import { getNeighbours } from \"./utility\";\n export function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  \n  let neighboursIndex = getNeighbours(node.row,node.col,grid);  \n  //  console.log( neighboursIndex);\n  let neighbours = [];\n  neighboursIndex.forEach((indices) => {\n    let m = indices[0];\n    let n = indices[1];\n    let neighbour =  grid[m][n];\n    neighbours.push(neighbour);\n  });\n  // for (const neighbor of neighbours) {\n  //   neighbor.distance = node.distance + 1;\n  //   neighbor.previousNode = node;\n  // } \n  updateNeighbours(neighbours, node, \"dijkstra\");\n}\n\n\nfunction updateNeighbours(neighbours, currNode, algo) {\n  let row = currNode.row;\n  let col = currNode.col;\n  let DiagonalId = [\n    `${row - 1}-${col - 1}`,\n    `${row - 1}-${col + 1}`,\n    `${row + 1}-${col - 1}`,\n    `${row + 1}-${col + 1}`,\n  ];\n  if (algo === \"dijkstra\") {\n    neighbours.forEach((neighbour) => { \n      //  if(!DiagonalId.includes( ))\n      // console.log('aaa');\n\n      if (!DiagonalId.includes(`${neighbour.row}-${neighbour.col}`)) {\n        if (1 + neighbour.weight + currNode.distance < neighbour.distance) {\n          neighbour.distance = 1 + neighbour.weight + currNode.distance;\n          neighbour.parent = currNode;\n          neighbour.previousNode = currNode;\n        }\n      } else {\n        if (1.4 + neighbour.weight + currNode.distance < neighbour.distance) {\n          neighbour.distance = 1.4 + neighbour.weight + currNode.distance; \n          // console.log( neighbour.distance);\n          neighbour.parent = currNode;\n          neighbour.previousNode = currNode;\n        }\n      }\n    });\n  }\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) { \n      if(! node.isWall===true)\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrderOfDijkstra(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.parent;\n  } \n//  console.log(currentNode.parent ); \n  return nodesInShortestPathOrder;\n}","import React, { Component } from 'react';  \n\nimport \"./node.css\"; \n\nclass Node extends Component {\n    state = {  \n       \n     }\n    render() {  \n        const {\n            col,\n            isFinish,\n            isStart,\n            isWall,\n            isvisited,\n            onMouseDown,\n            onMouseEnter,\n            onMouseUp, \n            weight,\n            row,\n            parent,f,g,h\n          } = this.props;\n          const extraClassName = isFinish ? 'node-finish' : \n           isStart ? 'node-start' : \n            isWall ? 'node-wall' : '';\n            // console.log( this.props);\n        return (  \n          <div\n            id={`node-${row}-${col}`}\n            className={`node ${extraClassName}`}\n            onMouseDown={() => onMouseDown(row, col)}\n            onMouseEnter={() => onMouseEnter(row, col)}\n            onMouseUp={() => onMouseUp(row, col)} \n            // onKeyDown={ ()=> onKeyDown()} \n            ></div>\n        );\n    }\n} \n \nexport default Node;","import React, { Component } from 'react'; \n// import {  minHeap, getNeighbours } from \"./utility\";\nimport { getNeighbours, minHeap } from \"./utility\";\n\n export const AStar = ( grid, startNode, finishNode) => { \n   const visitedNodesInOrder = [];\n   let openList = new minHeap(); \n   startNode.g = 0;\n  startNode.h = getDistance(startNode, finishNode);\n  startNode.f = startNode.g + startNode.h;\n  openList.push([startNode.f, startNode]); \n  \n  while (!openList.isEmpty()) {\n   // var currNode = new Node();\n   let currArr = openList.getMin();\n   let currNode = currArr[1]; \n   // console.log( currNode)(); \n   if( currNode === finishNode) \n    return  visitedNodesInOrder ; \n    if (currNode.isVisited || currNode.isWall) {\n      continue;\n    } \n    currNode.isVisited = true; \n    visitedNodesInOrder.push(currNode); \n    var neighboursIndex = getNeighbours(currNode.row, currNode.col, grid);\n    let neighbours = [];\n    neighboursIndex.forEach((indices) => {\n      let m = indices[0];\n      let n = indices[1];\n      let neighbour = grid[m][n];\n      neighbours.push(neighbour);\n    }); \n    updateNeighbours(neighbours, currNode, \"aStar\", finishNode); \n    for (let i = 0; i < neighbours.length; i++) {\n      let neighbour = neighbours[i];\n      visitedNodesInOrder.push(currNode); \n      openList.push([neighbour.f, neighbour]);\n    }   \n}  \nwhile (!openList.isEmpty()) {\n   // let cell = new Node();\n   let arr = openList.getMin();\n   let cell = arr[1];\n   if (cell.isVisited || cell.isWall) {\n     continue;\n   }\n   cell.isVisited = true;\n   // nodesToAnimate.push([cell, \"visited\"]); \n   visitedNodesInOrder.push(cell); \n }\n openList.clear();\n return visitedNodesInOrder;\n}\n\n function updateNeighbours(neighbours, currNode, algo, endNode) {\n   if (algo === \"aStar\") {\n     neighbours.forEach((neighbour) => {\n       var newGCost = currNode.g + neighbour.weight;\n \n       //Whenever weights are involved f(n) = g(n) + W*h(n)\n       let estimation_cost = getDistance(neighbour, endNode);\n       let newCost = newGCost + estimation_cost;\n       if (newCost < neighbour.f) {\n         neighbour.g = newGCost;\n         neighbour.f = newCost;\n         neighbour.h = estimation_cost;\n         neighbour.parent = currNode;\n       }\n     });\n   }\n }\n \n\nfunction getDistance(nodeA, nodeB) {\n   const diagonal = document.getElementById(\"diagonal-flag\").checked;\n   var dx = Math.abs(nodeA.row - nodeB.row);\n   var dy = Math.abs(nodeA.col - nodeB.col);\n   if (diagonal === false) {\n     //Manhattan Distance\n     return dx + dy;\n   } else {\n     if (dx > dy) {\n       //Better results than using sqrt(2) and 1\n       return 1.4 * dy + 1 * (dx - dy);\n     }\n     return 1.4 * dx + 1 * (dy - dx);\n   }\n }\n\n export const getNodesInShortestPathOrderOfAStar = ( finishNode) => {\n   const nodesInShortestPathOrder = [];\n   let currentNode = finishNode;\n   while (currentNode !== null) {\n     nodesInShortestPathOrder.unshift(currentNode);\n     currentNode = currentNode.parent;\n   } \n //  console.log(currentNode.parent ); \n   return nodesInShortestPathOrder;\n}\n","import { getNeighbours, minHeap } from \"./utility\";\n\nexport const Greedy_BFS = ( grid, startNode, finishNode) => {  \n    const visitedNodesInOrder = [];\n    let openList = new minHeap();\n    startNode.h = getDistance(startNode, finishNode); \n  startNode.f = startNode.h;\n  openList.push([startNode.f, startNode]);  \n\n\n  while (!openList.isEmpty()) {\n    // var currNode = new Node();\n    let currArr = openList.getMin();\n    let currNode = currArr[1]; \n    // console.log( currNode)(); \n    if( currNode === finishNode) \n     return  visitedNodesInOrder ; \n     if (currNode.isVisited || currNode.isWall) {\n       continue;\n     } \n     currNode.isVisited = true; \n     visitedNodesInOrder.push(currNode); \n     var neighboursIndex = getNeighbours(currNode.row, currNode.col, grid);\n     let neighbours = [];\n     neighboursIndex.forEach((indices) => {\n       let m = indices[0];\n       let n = indices[1];\n       let neighbour = grid[m][n];\n       neighbours.push(neighbour);\n     }); \n     updateNeighbours(neighbours, currNode,\"aStar\",  finishNode); \n     for (let i = 0; i < neighbours.length; i++) {\n       let neighbour = neighbours[i];\n       visitedNodesInOrder.push(currNode); \n       openList.push([neighbour.f, neighbour]);\n     }   \n }  \n \n while (!openList.isEmpty()) {\n    // let cell = new Node();\n    let arr = openList.getMin();\n    let cell = arr[1];\n    if (cell.isVisited || cell.isWall) {\n      continue;\n    }\n    cell.isVisited = true;\n    // nodesToAnimate.push([cell, \"visited\"]); \n    visitedNodesInOrder.push(cell); \n  }\n  openList.clear();\n  return visitedNodesInOrder;\n\n}\n\n\nfunction updateNeighbours(neighbours, currNode, algo, endNode) {\n  // if (algo === \"aStar\") {\n    neighbours.forEach((neighbour) => {\n      neighbour.h = neighbour.weight + getDistance(neighbour, endNode);\n    var newf = neighbour.h;\n    if (newf < neighbour.f) neighbour.f = newf;\n    neighbour.parent = currNode;\n    });\n  // }\n}\n\n  function getDistance(nodeA, nodeB) {\n    const diagonal = document.getElementById(\"diagonal-flag\").checked;\n    var dx = Math.abs(nodeA.row - nodeB.row);\n    var dy = Math.abs(nodeA.col - nodeB.col);\n    if (diagonal === false) {\n      //Manhattan Distance\n      return dx + dy;\n    } else {\n      // Diagonal Distance\n      if (dx > dy) {\n        return (1.4 * dy) + (1 * (dx - dy));\n      }\n      return (1.4 * dx) + (1 * (dy - dx));\n    }\n  } \n\n\n  export const getNodesInShortestPathOrderOfGreedyBfs = ( finishNode) => {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.parent;\n    } \n  //  console.log(currentNode.parent ); \n    return nodesInShortestPathOrder;\n }","\nlet minutes;\nlet seconds;\nlet milisec;\nlet started = false;\nlet interval;\nlet startTime = new Date();\nlet btnText;\n\n\n/**\n * helper function for start() function\n */\nexport function timer() {\n  const now = new Date();\n\n  const milisecond = now - startTime;\n  minutes = Math.floor(milisecond / (1000 * 60));\n  seconds = Math.floor((milisecond / 1000) % 60);\n  milisec = Math.floor(milisecond % 100);\n\n  // show 09 instead of 9 in case minutes, seconds or milisec are less than 10\n  minutes = minutes < 10 ? \"0\" + minutes : minutes;\n  seconds = seconds < 10 ? \"0\" + seconds : seconds;\n  milisec = milisec < 10 ? \"0\" + milisec : milisec;\n\n  document.getElementById('time-count').innerText =\"time -\"+\n    minutes + \" min \" + seconds + \" sec \" + milisec + \" ms \";\n}\n\nexport function start() {\n  // btnText = startBtnText; \n  //  console.log('start') \n  //  console.log( new Date()); \n  startTime = new Date();\n  if (started == false) {\n    interval = setInterval(timer, 10);\n    started = true;\n  } else {\n    clearInterval(interval);\n    started = false;\n  }\n}\n\n","import React, { Component } from 'react'; \nimport { dijkstra, getNodesInShortestPathOrderOfDijkstra } from '../algorithms/dijkstra';\nimport {BFS,getNodesInShortestPathOrderOfBFS} from '../algorithms/bfs';\nimport {AStar,getNodesInShortestPathOrderOfAStar} from '../algorithms/astar'; \nimport {Greedy_BFS,getNodesInShortestPathOrderOfGreedyBfs} from '../algorithms/greedy_bfs'; \n\nimport Navbar from './navbar';\nimport Node from '../node/node'; \nimport Instructions from './instructions';\n\nimport { start } from '../timer';\n\nimport \"./visualizer.css\";\n\n\n\nlet START_NODE_ROW = 5;\nlet START_NODE_COL = 5;\nlet FINISH_NODE_ROW = 30;\nlet FINISH_NODE_COL = 15; \nlet  isWPressed = false;  \nconst height = window.innerHeight * 0.8;\nconst width = window.innerWidth * 0.9; \n export const no_of_row= Math.floor(width / 25) - 1;\n export const no_of_column=Math.floor(height / 25) - 1;\n//  console.log( no_of_row);\n//  console.log( width);\n   \n\n\n\nexport default class Visualizer extends Component {\n    state = {  \n        grid: [], \n        startchange: false,\n        endchange: false,   \n        currentAlgorithm: null,\n      mouseIsPressed: false,\n     }  \n\n\n     componentDidMount() {\n        const grid = getInitialGrid();\n        this.setState({grid});\n        // console.log( grid);\n      }  \n\n      \n      \n  handleMouseDown=(row, col)=> {  \n     const { grid} = this.state;\n     if( isWPressed) \n     {    this.setState({mouseIsPressed: true});  \n     setTimeout(() => {\n      // console.log( document.getElementById(`node-${row}-${col}`)); \n      const newGrid = grid.slice();  \n      const Node = newGrid[row][col];\n     let newNode= {};\n     newNode = {\n      ...Node,\n      weight:2.0\n     }; \n     newGrid[row][col]=newNode;\n     this.setState({ grid:newGrid}); \n  \n      document.getElementById(`node-${row}-${col}`).className =`node  node-weighted`;\n    }, 10);\n    }\n     \n\n    if( row === START_NODE_ROW && col === START_NODE_COL) \n     {    this.setState({startchange:true,mouseIsPressed: true});   \n     return;  }\n    if( row === FINISH_NODE_ROW && col === FINISH_NODE_COL)  \n    {  \n      this.setState({endchange:true,mouseIsPressed: true});   \n     return;  }\n    if(!isWPressed) { const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({grid: newGrid, mouseIsPressed: true}); }\n  } \n  handleMouseEnter=(row, col) =>{ \n    if (!this.state.mouseIsPressed) return; \n\n      const { grid} = this.state;\n    if( isWPressed) \n    {    this.setState({mouseIsPressed: true});  \n    setTimeout(() => {\n     // console.log( 'aaa'); \n     const newGrid = grid.slice();  \n     const Node = newGrid[row][col];\n    let newNode= {};\n    newNode = {\n     ...Node,\n     weight:2.0\n    }; \n    newGrid[row][col]=newNode;\n    this.setState({ grid:newGrid}); \n    console.log( grid[row][col] );\n     document.getElementById(`node-${row}-${col}`).className =`node  node-weighted`;\n   }, 10);\n  }\n    const{ startchange, endchange}= this.state;  \n    if(startchange) \n    { \n      const newGrid =changeStartPoint(this.state.grid, row, col, 1);\n      this.setState({grid: newGrid});\n      START_NODE_ROW = row;\n      START_NODE_COL = col;  \n      const newstGrid =changeStartPoint(this.state.grid, row, col, 0, 1);\n      this.setState({grid: newstGrid});\n      \n    }  \n    else if(endchange) \n    { \n      const newGrid =changeEndPoint(this.state.grid, row, col, 1);\n      this.setState({grid: newGrid});\n     FINISH_NODE_ROW = row;\n      FINISH_NODE_COL = col;  \n      const newstGrid =changeEndPoint(this.state.grid, row, col,  0, 1);\n      this.setState({grid: newstGrid});\n      \n    } \n   else if( !isWPressed) { const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({grid: newGrid}); }\n  }\n\n  handleMouseUp=(row,col)=> { \n    const{ startchange, endchange}= this.state; \n    if( startchange) { this.setState({startchange:false,mouseIsPressed: false}); }\n  else  if( endchange) this.setState({endchange:false,mouseIsPressed: false}); \n    else  this.setState({mouseIsPressed: false}); \n  \n  }    \n \n  animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder) {\n     start();\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) { \n        \n        setTimeout(() => {  \n          document.getElementById('distacne-count').innerHTML= `distance count -  ${nodesInShortestPathOrder.length-1 }`; \n          start();\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i]; \n        if(!node.isWall)\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          `node  ${ node.row===START_NODE_ROW && node.col===START_NODE_COL ?'node-start': \n          node.row===FINISH_NODE_ROW && node.col===FINISH_NODE_COL? 'node-finish':node.iswall?'node-wall':'node-visited'}`;\n      }, 10 * i);\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    // console.log(this.state.grid); \n   \n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          `node  ${ node.row===START_NODE_ROW && node.col===START_NODE_COL ?'node-start': \n           node.row===FINISH_NODE_ROW && node.col===FINISH_NODE_COL? 'node-finish':'node-shortest-path'}`;\n      }, 50 * i); \n    } \n   \n  }\n \n  visualizeAlgorithm =( name)=> {\n    const {grid} = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];  \n    let visitedNodesInOrder; let nodesInShortestPathOrder;\n    // console.log( name);\n    if( name ==='dijkstra'){ \n      \n     visitedNodesInOrder = dijkstra(grid, startNode, finishNode); \n      \n     nodesInShortestPathOrder = getNodesInShortestPathOrderOfDijkstra( finishNode); \n    }  \n    else if( name ==='BFS') \n    {\n      visitedNodesInOrder = BFS(grid, startNode, finishNode);  \n      nodesInShortestPathOrder = getNodesInShortestPathOrderOfBFS(finishNode);  \n    } \n    else if( name ==='A*') \n    {\n      visitedNodesInOrder = AStar(grid, startNode, finishNode);  \n      nodesInShortestPathOrder = getNodesInShortestPathOrderOfAStar(finishNode);  \n    }  \n    else if( name ==='Greedy-best-first') \n    {\n      visitedNodesInOrder = Greedy_BFS(grid, startNode, finishNode);  \n      nodesInShortestPathOrder = getNodesInShortestPathOrderOfGreedyBfs(finishNode);  \n    }  \n    else { \n       return;\n    }\n    // console.log( nodesInShortestPathOrder);   \n    // console.log( visitedNodesInOrder);   \n     if( nodesInShortestPathOrder.length==1)  \n    {  \n      document.getElementById('input-message').innerHTML= `Path not  Found `;\n    } \n      else\n    { \n      document.getElementById('input-message').innerHTML= `Path Found successfully`;  \n    }\n      \n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n  } \n  \n  \n  \n  \n  resetGrid =( )=> {\n    //  const { grid} = this.state; \n     const grid = [];\n     for (let row = 0; row < no_of_row; row++) {\n       const currentRow = [];\n       for (let col = 0; col < no_of_column; col++) {\n          currentRow.push(createNode(col, row)); \n          //`node-${row}-${col}`\n      document.getElementById(`node-${row}-${col}`).className =\n        `node  ${ row===START_NODE_ROW && col===START_NODE_COL ?'node-start': \n         row===FINISH_NODE_ROW && col===FINISH_NODE_COL? 'node-finish':''}`;\n       \n       }\n       grid.push(currentRow);\n     } \n     document.getElementById('input-message').innerHTML= `successfully Grid cleared`;\n     document.getElementById('distacne-count').innerHTML= `distance count - 0`;  \n     document.getElementById('time-count').innerHTML= ` time- 00 min 00 sec 00 ms`;  \n       this.setState({ grid});\n    // console.log(grid); \n  } \n\n   clearPath=()=> {\n     const { grid}= this.state;  \n     const gridNew = []; \n     for (let row = 0; row < no_of_row; row++) {\n      const currentRow = [];\n      for (let col = 0; col < no_of_column; col++) {\n         currentRow.push(createNode(col, row,grid[row][col].isWall));  \n        if(grid[row][col].isWall) { \n          document.getElementById(`node-${row}-${col}`).className='node node-wall'; }\n      else { document.getElementById(`node-${row}-${col}`).className =\n       `node  ${ row===START_NODE_ROW && col===START_NODE_COL ?'node-start': \n        row===FINISH_NODE_ROW && col===FINISH_NODE_COL? 'node-finish':''}`; }\n      \n      }\n      gridNew.push(currentRow);\n    }  //document.getElementById('input-message').className= `highlight`;\n    document.getElementById('input-message').innerHTML= `successfully path cleared`;\n    document.getElementById('distacne-count').innerHTML= `distance count - 0`; \n    document.getElementById('time-count').innerHTML= ` time- 00 min 00 sec 00 ms`;   \n      this.setState({ grid: gridNew});\n    //  console.log( grid);\n   }\n\n   \n\n  \n\n    render() {    \n     \n      window.addEventListener(\"keydown\", (e) => {\n        if( e.key ===\"w\")  isWPressed= true; \n        \n      }); \n      window.addEventListener(\"keyup\", (e) => {\n        if( e.key ===\"w\")  isWPressed= false; \n        \n      });\n        const {grid,mouseIsPressed}= this.state;\n        \n        return (  \n        //  \n          <div> \n             \n             < Navbar \n              clearPath= {this.clearPath} \n              resetGrid = { this.resetGrid} \n              visualizeAlgorithm = { this.visualizeAlgorithm}\n               />\n               {/* <Instructions/> */}\n            < div className = ' my-3' > \n            < span className = 'distance-count px-0' id='distacne-count'> \n                distance count - 0\n              </ span> \n              < span className = 'message-show px-5' id='input-message'> \n              Select an ALgorithm first\n              </ span> \n              < span className = 'time-count px-5' id='time-count'> \n               time- 00 min 00 sec 00 ms\n              </ span>\n            </div> \n            \n          \n            <div className=\"grid\">\n            {grid.map((row, rowIdx) => {\n              return ( \n\n                <div key={rowIdx} className=\"gridRow\">\n                  {row.map((node, nodeIdx) => {\n                     const {row, col, isFinish, isStart, isWall, isVisited,parent,isWeighted,f,g,h} = node; \n                    // console.log( 'a');\n                     return (\n                       <Node\n                       key={nodeIdx} \n                       row={row}\n                       col={col}\n                       isFinish={isFinish}\n                       isStart={isStart}\n                       isWall={isWall} \n                       isVisited={isVisited}\n                       isWeighted= { isWeighted}\n                       parent={parent}\n                       mouseIsPressed={mouseIsPressed}\n                       f={f}\n                       g={g}\n                       h={h}\n                       onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                       onMouseEnter={(row, col) => {return  this.handleMouseEnter(row, col)}}\n                       onMouseUp={(row, col) => { return this.handleMouseUp(row,col)}}\n\n                      //  onKeyDown={ ()=> { return this.handleKeyPress } }\n                       ></Node>\n                    );\n                  })}\n                </div>\n              );\n            })}\n          </div>\n          </div>\n         );\n    }\n}\n // row= 60, col= 20  \n\n \nconst getInitialGrid = () => { \n  \n    const grid = [];\n    for (let row = 0; row < no_of_row; row++) {\n      const currentRow = [];\n      for (let col = 0; col < no_of_column; col++) {\n        currentRow.push(createNode(col,row));\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  }; \n\n  \nconst createNode = ( col,row,wall=false) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: wall, \n    weight:1.0, \n    f: Infinity,\n    g: Infinity,\n    h: Infinity,\n    parent :null,\n    previousNode: null,\n    \n  };\n}; \n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];  \n   let newNode= {};\n   newNode = {\n    ...node,\n    isWall: !node.isWall, \n  }; \n newGrid[row][col] = newNode; \n  return newGrid;\n}; \n\n\nconst changeStartPoint = (grid, row, col, previousStart=0, newStart=0) => {\n  const newGrid = grid.slice();  \n  const startNode = newGrid[START_NODE_ROW][START_NODE_COL];  \n   let newNode= {};\n   let previousNode= {};\n  if(previousStart)  \n  {\n    previousNode = {\n      ...startNode,\n      isStart: false\n    }; \n    newGrid[START_NODE_ROW][START_NODE_COL]=previousNode;\n   }  \n   \n   if(newStart)  \n   {\n     newNode = {\n       ...startNode,\n       isStart: true\n     }; \n     newGrid[START_NODE_ROW][START_NODE_COL]=newNode;\n    }  \n\n  return newGrid;\n}; \n\n\nconst changeEndPoint = (grid, row, col,  previousEnd=0,newEnd=0) => {\n  const newGrid = grid.slice();  \n  const endNode = newGrid[FINISH_NODE_ROW][FINISH_NODE_COL];\n   let newNode= {};\n   let previousNode= {};\n  \n   if(previousEnd)  \n  {\n    previousNode = {\n      ...endNode,\n      isFinish: false\n    }; \n    newGrid[FINISH_NODE_ROW][FINISH_NODE_COL]=previousNode;\n   } \n   \n    if(newEnd)  \n  {\n    newNode = {\n      ...endNode,\n      isFinish: true\n    }; \n    newGrid[FINISH_NODE_ROW][FINISH_NODE_COL]=newNode;\n   } \n  return newGrid;\n};\n","import { Queue, getNeighbours } from \"./utility\";\nimport Node from \"../node/node\";\n\n\n\nexport function BFS(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n // const nodesInShortestPathOrder=[];\n  let myQueue = new Queue();\n  \n  startNode.isVisited = true;\n  myQueue.enqueue(startNode);\n\n  visitedNodesInOrder.push(startNode);\n  let currNode = new Node();\n  \n  // dequeue till queue becomes empty or finds end node\n  while (!myQueue.empty()) { \n    currNode = myQueue.dequeue(); \n    // if (currNode.isWall) {console.log(currNode.row)};\n   \n    if (currNode.isWall){ continue;}\n    var r = currNode.row;\n    var c = currNode.col;\n    visitedNodesInOrder.push(currNode);\n    if (currNode === finishNode) {\n    // pathFound = true;\n      break;\n    }\n    currNode.isVisited = true;\n    var neighbours = getNeighbours(r, c,grid);\n    // console.log(neighbours);\n    for (var k = 0; k < neighbours.length; k++) {\n      var m = neighbours[k][0];\n      var n = neighbours[k][1];\n\n      let node = new Node();\n      node = grid[m][n];\n      grid[m][n].isVisited = true;\n      grid[m][n].parent = currNode;\n     visitedNodesInOrder.push(node);\n      myQueue.enqueue(node);\n      // if(myQueue.items.empty){console.log('aa');}\n      // console.log(myQueue);\n    }\n  }\n    return visitedNodesInOrder; \n  }\n\n\nexport function getNodesInShortestPathOrderOfBFS(finishNode) {\n  \n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.parent;\n  \n}\n  return nodesInShortestPathOrder;\n}","// import logo from './logo.svg';\nimport './App.css'; \nimport './background.css';\nimport './visulaizer/instructions'\n//import Navbar from './visulaizer/navbar';\nimport Visualizer from './visulaizer/visualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">  \n     <div id=\"stars\" />\n     <div id=\"stars2\" />\n      <div id=\"stars\" />\n      \n      <Visualizer/> \n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}